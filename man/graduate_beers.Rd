% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/graduate.R
\name{graduate_beers}
\alias{graduate_beers}
\title{The ordinary modified Beers splitting methods}
\usage{
graduate_beers(Value, Age, AgeInt, OAG = TRUE, method = "ord", johnson = FALSE)
}
\arguments{
\item{Value}{numeric vector, presumably counts in grouped ages}

\item{Age}{integer vector, lower bounds of age groups}

\item{AgeInt}{integer vector, age interval widths}

\item{OAG}{logical, default = \code{TRUE} is the final age group open?}

\item{method}{character. Valid values are \code{"ord"} or \code{"mod"}. Default \code{"ord"}.}

\item{johnson}{logical. Whether or not to adjust young ages according to the \href{https://www.census.gov/data/software/dapps.html}{Demographic Analysis & Population Projection System Software} method. Default \code{FALSE.}}
}
\value{
A numeric vector of single age data.
}
\description{
This method offers both ordinary and modified Beers splitting, with an optional \href{https://www.census.gov/data/software/dapps.html}{Demographic Analysis & Population Projection System Software} adjustment \code{johnson} for ages under 10.
}
\details{
Ages should refer to lower age bounds. \code{Value} must be labeled with ages unless \code{Age} is given separately. There must be at least six 5-year age groups (including the open group, 5 otherwise). If you want the \code{johnson} adjustment then \code{Value} must contain a single-year estimate of the population count in age 0. That means \code{Value} must come either as standard abridged or single age data.

\code{method} option \code{"ord"} conserves sums in 5-year age groups, whereas \code{"mod"} does some smoothing between 5-year age groups too, and is not constrained.

If the highest age does not end in a 0 or 5, and \code{OAG == TRUE}, then the open age will be grouped down to the next highest age ending in 0 or 5. If the highest age does not end in a 0 or 5, and \code{OAG = FALSE}, then results extend to single ages covering the entire 5-year age group.
}
\examples{
p5 <- pop5_mat
a5 <- as.integer(rownames(p5))
head(p5) # this is the entire matrix
p1 <- graduate_beers(p5[,1], Age = a5, OAG = FALSE)
head(p1)
# note some negatives in high ages
tail(p1)
sum(p1) - sum(p5[,1])

# another case, starting with single ages
# note beers() groups ages.
Value        <- pop1m_ind
Age          <- 0:100
names(Value) <- Age
ord1 <-  graduate_beers(Value, Age, OAG = TRUE, method = "ord")
mod1 <- graduate_beers(Value, Age, OAG = TRUE, method = "mod")
\dontrun{
plot(Age,Value,
ylab = 'The counts', xlab = 'Age groups')
lines(Age, ord1, t='l', col='blue')
lines(Age, mod1, t = 'l', col ='red', lty =2)
legend(80,15000000,
      legend = c('Ordinary',
                 'Modified'),
      col=c('blue', 'red'),
      lty = c(1,2))
}

# notice this negative value. Yuck!
tail(mod1)
# this replaces ages 90+, guaranteed no negatives.
graduate_mono_closeout(Value, Age = Age, pops = mod1, OAG = TRUE)
# Note: there are no kludges built into beers() to handle such cases.
# graduate() deals with this automatically.

# This replicates Johnson_2016_BEERSP.XLS, males
M <- c(184499,752124-184499,582662,463534,369976,286946,235867,
		199561,172133,151194,131502,113439,95614,
		78777,60157,40960,21318,25451)
Age <- c(0,1,seq(5,80,by=5))
Age0        <- 184499
johnson     <- graduate_beers(
		         Value = M,
		         Age = Age,
		         OAG = TRUE,
			       method = "ord",
			       johnson = TRUE)
}
\references{
\insertRef{beers1945modified}{DemoTools}
\insertRef{shryock1973methods}{DemoTools}
\insertRef{siegel2004methods}{DemoTools}
\insertRef{stover2008spectrum}{DemoTools}
}
