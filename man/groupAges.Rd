% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utilsAge.R
\name{groupAges}
\alias{groupAges}
\title{Group single ages into equal age groups of arbitrary width}
\usage{
groupAges(
  Value,
  Age = 1:length(Value) - 1,
  N = 5,
  shiftdown = 0,
  AgeN,
  OAnew = max(Age)
)
}
\arguments{
\item{Value}{numeric. Vector of single age counts.}

\item{Age}{integer. Vector of lower bounds of single age groups.}

\item{N}{integer. The desired width of resulting age groups. Default 5.}

\item{shiftdown}{integer. Optionally shift age groupings down by single ages. Default 0.}

\item{AgeN}{integer vector, otherwise calculated using \code{calcAgeN()}. Optional argument.}

\item{OAnew}{integer. Value of lower bound of new open age group.}
}
\value{
Vector of counts in N-year age groups.
}
\description{
This can be useful to check constrained sums, or as an intermediate step for smoothing.
}
\details{
If you shift the groupings, then the first age groups may have a negative lower bound
(for example of -5). These counts would be discarded for the oscillatory version of Sprague smoothing,
for example, but they are preserved in this function. The important thing to know is that if you shift
the groups, the first and last groups will not be N years wide. For example if \code{shiftdown} is 1, the first age group is 4-ages wide. The ages themselves are not returned,
but they are the name attribute of the output count vector. Note this will also correctly group abridged ages
into equal 5-year age groups if the \code{Age} argument is explicitly given. \code{OAnew} (optional) must be less than or equal to \code{max(Age)} to have any effect.
}
\examples{
 Age <- 0:100
 groupAges(pop1m_ind, N = 5)
 groupAges(pop1m_ind, N = 5, shiftdown = 1)
 groupAges(pop1m_ind, N = 5, shiftdown = 2)
 groupAges(pop1m_ind, N = 5, shiftdown = 3)
 groupAges(pop1m_ind, N = 5, shiftdown = 4)
 groupAges(pop1m_ind, N = 5, OAnew = 80)
}
